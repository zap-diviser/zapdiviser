/**
 * Generated by @openapi-codegen
 *
 * @version 1.0.0
 */
import * as reactQuery from '@tanstack/react-query';
import { useZapdiviserContext, ZapdiviserContext } from './zapdiviserContext';
import type * as Fetcher from './zapdiviserFetcher';
import { zapdiviserFetch } from './zapdiviserFetcher';
import type * as Schemas from './zapdiviserSchemas';

export type UserControllerFindMeError = Fetcher.ErrorWrapper<undefined>;

export type UserControllerFindMeVariables = ZapdiviserContext['fetcherOptions'];

export const fetchUserControllerFindMe = (variables: UserControllerFindMeVariables, signal?: AbortSignal) =>
  zapdiviserFetch<Record<string, any>, UserControllerFindMeError, undefined, {}, {}, {}>({
    url: '/api/user',
    method: 'get',
    ...variables,
    signal
  });

export const useUserControllerFindMe = <TData = Record<string, any>>(
  variables: UserControllerFindMeVariables,
  options?: Omit<reactQuery.UseQueryOptions<Record<string, any>, UserControllerFindMeError, TData>, 'queryKey' | 'queryFn' | 'initialData'>
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useZapdiviserContext(options);
  return reactQuery.useQuery<Record<string, any>, UserControllerFindMeError, TData>({
    queryKey: queryKeyFn({ path: '/api/user', operationId: 'userControllerFindMe', variables }),
    queryFn: ({ signal }) => fetchUserControllerFindMe({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type UserControllerUpdateError = Fetcher.ErrorWrapper<undefined>;

export type UserControllerUpdateVariables = {
  body: Schemas.UpdateUserDto;
} & ZapdiviserContext['fetcherOptions'];

export const fetchUserControllerUpdate = (variables: UserControllerUpdateVariables, signal?: AbortSignal) =>
  zapdiviserFetch<Record<string, any>, UserControllerUpdateError, Schemas.UpdateUserDto, {}, {}, {}>({
    url: '/api/user',
    method: 'patch',
    ...variables,
    signal
  });

export const useUserControllerUpdate = (
  options?: Omit<reactQuery.UseMutationOptions<Record<string, any>, UserControllerUpdateError, UserControllerUpdateVariables>, 'mutationFn'>
) => {
  const { fetcherOptions } = useZapdiviserContext();
  return reactQuery.useMutation<Record<string, any>, UserControllerUpdateError, UserControllerUpdateVariables>({
    mutationFn: (variables: UserControllerUpdateVariables) => fetchUserControllerUpdate({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type UserControllerCreateRecoveryCodeError = Fetcher.ErrorWrapper<undefined>;

export type UserControllerCreateRecoveryCodeVariables = {
  body: Schemas.ForgetPasswordDto;
} & ZapdiviserContext['fetcherOptions'];

export const fetchUserControllerCreateRecoveryCode = (variables: UserControllerCreateRecoveryCodeVariables, signal?: AbortSignal) =>
  zapdiviserFetch<undefined, UserControllerCreateRecoveryCodeError, Schemas.ForgetPasswordDto, {}, {}, {}>({
    url: '/api/user/forget-password',
    method: 'post',
    ...variables,
    signal
  });

export const useUserControllerCreateRecoveryCode = (
  options?: Omit<
    reactQuery.UseMutationOptions<undefined, UserControllerCreateRecoveryCodeError, UserControllerCreateRecoveryCodeVariables>,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useZapdiviserContext();
  return reactQuery.useMutation<undefined, UserControllerCreateRecoveryCodeError, UserControllerCreateRecoveryCodeVariables>({
    mutationFn: (variables: UserControllerCreateRecoveryCodeVariables) =>
      fetchUserControllerCreateRecoveryCode({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type UserControllerCheckCodeError = Fetcher.ErrorWrapper<undefined>;

export type UserControllerCheckCodeVariables = {
  body: Schemas.CheckCodeDto;
} & ZapdiviserContext['fetcherOptions'];

export const fetchUserControllerCheckCode = (variables: UserControllerCheckCodeVariables, signal?: AbortSignal) =>
  zapdiviserFetch<boolean, UserControllerCheckCodeError, Schemas.CheckCodeDto, {}, {}, {}>({
    url: '/api/user/forget-password/check-code',
    method: 'post',
    ...variables,
    signal
  });

export const useUserControllerCheckCode = (
  options?: Omit<reactQuery.UseMutationOptions<boolean, UserControllerCheckCodeError, UserControllerCheckCodeVariables>, 'mutationFn'>
) => {
  const { fetcherOptions } = useZapdiviserContext();
  return reactQuery.useMutation<boolean, UserControllerCheckCodeError, UserControllerCheckCodeVariables>({
    mutationFn: (variables: UserControllerCheckCodeVariables) => fetchUserControllerCheckCode({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type UserControllerForgetPasswordWithCodeError = Fetcher.ErrorWrapper<undefined>;

export type UserControllerForgetPasswordWithCodeVariables = {
  body: Schemas.ForgetPasswordWithCodeDto;
} & ZapdiviserContext['fetcherOptions'];

export const fetchUserControllerForgetPasswordWithCode = (variables: UserControllerForgetPasswordWithCodeVariables, signal?: AbortSignal) =>
  zapdiviserFetch<undefined, UserControllerForgetPasswordWithCodeError, Schemas.ForgetPasswordWithCodeDto, {}, {}, {}>({
    url: '/api/user/forget-password/code',
    method: 'post',
    ...variables,
    signal
  });

export const useUserControllerForgetPasswordWithCode = (
  options?: Omit<
    reactQuery.UseMutationOptions<undefined, UserControllerForgetPasswordWithCodeError, UserControllerForgetPasswordWithCodeVariables>,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useZapdiviserContext();
  return reactQuery.useMutation<undefined, UserControllerForgetPasswordWithCodeError, UserControllerForgetPasswordWithCodeVariables>({
    mutationFn: (variables: UserControllerForgetPasswordWithCodeVariables) =>
      fetchUserControllerForgetPasswordWithCode({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type UserControllerChangePasswordError = Fetcher.ErrorWrapper<undefined>;

export type UserControllerChangePasswordVariables = {
  body?: Schemas.UpdatePasswordWithOldPasswordDto;
} & ZapdiviserContext['fetcherOptions'];

export const fetchUserControllerChangePassword = (variables: UserControllerChangePasswordVariables, signal?: AbortSignal) =>
  zapdiviserFetch<undefined, UserControllerChangePasswordError, Schemas.UpdatePasswordWithOldPasswordDto, {}, {}, {}>({
    url: '/api/user/change-password/old-password',
    method: 'post',
    ...variables,
    signal
  });

export const useUserControllerChangePassword = (
  options?: Omit<
    reactQuery.UseMutationOptions<undefined, UserControllerChangePasswordError, UserControllerChangePasswordVariables>,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useZapdiviserContext();
  return reactQuery.useMutation<undefined, UserControllerChangePasswordError, UserControllerChangePasswordVariables>({
    mutationFn: (variables: UserControllerChangePasswordVariables) =>
      fetchUserControllerChangePassword({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type UserControllerChangePasswordWithTokenError = Fetcher.ErrorWrapper<undefined>;

export type UserControllerChangePasswordWithTokenVariables = {
  body?: Schemas.UpdatePasswordWithTokenDto;
} & ZapdiviserContext['fetcherOptions'];

export const fetchUserControllerChangePasswordWithToken = (
  variables: UserControllerChangePasswordWithTokenVariables,
  signal?: AbortSignal
) =>
  zapdiviserFetch<undefined, UserControllerChangePasswordWithTokenError, Schemas.UpdatePasswordWithTokenDto, {}, {}, {}>({
    url: '/api/user/change-password/token',
    method: 'post',
    ...variables,
    signal
  });

export const useUserControllerChangePasswordWithToken = (
  options?: Omit<
    reactQuery.UseMutationOptions<undefined, UserControllerChangePasswordWithTokenError, UserControllerChangePasswordWithTokenVariables>,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useZapdiviserContext();
  return reactQuery.useMutation<undefined, UserControllerChangePasswordWithTokenError, UserControllerChangePasswordWithTokenVariables>({
    mutationFn: (variables: UserControllerChangePasswordWithTokenVariables) =>
      fetchUserControllerChangePasswordWithToken({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type AuthControllerCreateError = Fetcher.ErrorWrapper<undefined>;

export type AuthControllerCreateVariables = {
  body: Schemas.CreateUserDto;
} & ZapdiviserContext['fetcherOptions'];

export const fetchAuthControllerCreate = (variables: AuthControllerCreateVariables, signal?: AbortSignal) =>
  zapdiviserFetch<Record<string, any>, AuthControllerCreateError, Schemas.CreateUserDto, {}, {}, {}>({
    url: '/api/auth/register',
    method: 'post',
    ...variables,
    signal
  });

export const useAuthControllerCreate = (
  options?: Omit<reactQuery.UseMutationOptions<Record<string, any>, AuthControllerCreateError, AuthControllerCreateVariables>, 'mutationFn'>
) => {
  const { fetcherOptions } = useZapdiviserContext();
  return reactQuery.useMutation<Record<string, any>, AuthControllerCreateError, AuthControllerCreateVariables>({
    mutationFn: (variables: AuthControllerCreateVariables) => fetchAuthControllerCreate({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type AuthControllerLoginError = Fetcher.ErrorWrapper<undefined>;

export type AuthControllerLoginVariables = {
  body: Schemas.LoginUserDto;
} & ZapdiviserContext['fetcherOptions'];

export const fetchAuthControllerLogin = (variables: AuthControllerLoginVariables, signal?: AbortSignal) =>
  zapdiviserFetch<undefined, AuthControllerLoginError, Schemas.LoginUserDto, {}, {}, {}>({
    url: '/api/auth/login',
    method: 'post',
    ...variables,
    signal
  });

export const useAuthControllerLogin = (
  options?: Omit<reactQuery.UseMutationOptions<undefined, AuthControllerLoginError, AuthControllerLoginVariables>, 'mutationFn'>
) => {
  const { fetcherOptions } = useZapdiviserContext();
  return reactQuery.useMutation<undefined, AuthControllerLoginError, AuthControllerLoginVariables>({
    mutationFn: (variables: AuthControllerLoginVariables) => fetchAuthControllerLogin({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type RedirectsControllerRedirectPathParams = {
  slug: string;
};

export type RedirectsControllerRedirectError = Fetcher.ErrorWrapper<undefined>;

export type RedirectsControllerRedirectVariables = {
  pathParams: RedirectsControllerRedirectPathParams;
} & ZapdiviserContext['fetcherOptions'];

export const fetchRedirectsControllerRedirect = (variables: RedirectsControllerRedirectVariables, signal?: AbortSignal) =>
  zapdiviserFetch<undefined, RedirectsControllerRedirectError, undefined, {}, {}, RedirectsControllerRedirectPathParams>({
    url: '/api/redirects/{slug}',
    method: 'get',
    ...variables,
    signal
  });

export const useRedirectsControllerRedirect = <TData = undefined>(
  variables: RedirectsControllerRedirectVariables,
  options?: Omit<reactQuery.UseQueryOptions<undefined, RedirectsControllerRedirectError, TData>, 'queryKey' | 'queryFn' | 'initialData'>
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useZapdiviserContext(options);
  return reactQuery.useQuery<undefined, RedirectsControllerRedirectError, TData>({
    queryKey: queryKeyFn({ path: '/api/redirects/{slug}', operationId: 'redirectsControllerRedirect', variables }),
    queryFn: ({ signal }) => fetchRedirectsControllerRedirect({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type RedirectsControllerCreateError = Fetcher.ErrorWrapper<undefined>;

export type RedirectsControllerCreateVariables = {
  body: Schemas.CreateRedirectDto;
} & ZapdiviserContext['fetcherOptions'];

export const fetchRedirectsControllerCreate = (variables: RedirectsControllerCreateVariables, signal?: AbortSignal) =>
  zapdiviserFetch<undefined, RedirectsControllerCreateError, Schemas.CreateRedirectDto, {}, {}, {}>({
    url: '/api/redirects',
    method: 'post',
    ...variables,
    signal
  });

export const useRedirectsControllerCreate = (
  options?: Omit<reactQuery.UseMutationOptions<undefined, RedirectsControllerCreateError, RedirectsControllerCreateVariables>, 'mutationFn'>
) => {
  const { fetcherOptions } = useZapdiviserContext();
  return reactQuery.useMutation<undefined, RedirectsControllerCreateError, RedirectsControllerCreateVariables>({
    mutationFn: (variables: RedirectsControllerCreateVariables) => fetchRedirectsControllerCreate({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type RedirectsControllerFindAllError = Fetcher.ErrorWrapper<undefined>;

export type RedirectsControllerFindAllResponse = Schemas.RedirectEntity[];

export type RedirectsControllerFindAllVariables = ZapdiviserContext['fetcherOptions'];

export const fetchRedirectsControllerFindAll = (variables: RedirectsControllerFindAllVariables, signal?: AbortSignal) =>
  zapdiviserFetch<RedirectsControllerFindAllResponse, RedirectsControllerFindAllError, undefined, {}, {}, {}>({
    url: '/api/redirects',
    method: 'get',
    ...variables,
    signal
  });

export const useRedirectsControllerFindAll = <TData = RedirectsControllerFindAllResponse>(
  variables: RedirectsControllerFindAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<RedirectsControllerFindAllResponse, RedirectsControllerFindAllError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useZapdiviserContext(options);
  return reactQuery.useQuery<RedirectsControllerFindAllResponse, RedirectsControllerFindAllError, TData>({
    queryKey: queryKeyFn({ path: '/api/redirects', operationId: 'redirectsControllerFindAll', variables }),
    queryFn: ({ signal }) => fetchRedirectsControllerFindAll({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type RedirectsControllerCreateLinkPathParams = {
  id: string;
};

export type RedirectsControllerCreateLinkError = Fetcher.ErrorWrapper<undefined>;

export type RedirectsControllerCreateLinkVariables = {
  body: Schemas.CreateRedirectLinkDto;
  pathParams: RedirectsControllerCreateLinkPathParams;
} & ZapdiviserContext['fetcherOptions'];

export const fetchRedirectsControllerCreateLink = (variables: RedirectsControllerCreateLinkVariables, signal?: AbortSignal) =>
  zapdiviserFetch<
    undefined,
    RedirectsControllerCreateLinkError,
    Schemas.CreateRedirectLinkDto,
    {},
    {},
    RedirectsControllerCreateLinkPathParams
  >({ url: '/api/redirects/{id}/link', method: 'post', ...variables, signal });

export const useRedirectsControllerCreateLink = (
  options?: Omit<
    reactQuery.UseMutationOptions<undefined, RedirectsControllerCreateLinkError, RedirectsControllerCreateLinkVariables>,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useZapdiviserContext();
  return reactQuery.useMutation<undefined, RedirectsControllerCreateLinkError, RedirectsControllerCreateLinkVariables>({
    mutationFn: (variables: RedirectsControllerCreateLinkVariables) =>
      fetchRedirectsControllerCreateLink({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type RedirectsControllerSlugAvailablePathParams = {
  slug: string;
};

export type RedirectsControllerSlugAvailableError = Fetcher.ErrorWrapper<undefined>;

export type RedirectsControllerSlugAvailableVariables = {
  pathParams: RedirectsControllerSlugAvailablePathParams;
} & ZapdiviserContext['fetcherOptions'];

export const fetchRedirectsControllerSlugAvailable = (variables: RedirectsControllerSlugAvailableVariables, signal?: AbortSignal) =>
  zapdiviserFetch<undefined, RedirectsControllerSlugAvailableError, undefined, {}, {}, RedirectsControllerSlugAvailablePathParams>({
    url: '/api/redirects/slug-available/{slug}',
    method: 'get',
    ...variables,
    signal
  });

export const useRedirectsControllerSlugAvailable = <TData = undefined>(
  variables: RedirectsControllerSlugAvailableVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, RedirectsControllerSlugAvailableError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useZapdiviserContext(options);
  return reactQuery.useQuery<undefined, RedirectsControllerSlugAvailableError, TData>({
    queryKey: queryKeyFn({ path: '/api/redirects/slug-available/{slug}', operationId: 'redirectsControllerSlugAvailable', variables }),
    queryFn: ({ signal }) => fetchRedirectsControllerSlugAvailable({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type RedirectsControllerFindOnePathParams = {
  id: string;
};

export type RedirectsControllerFindOneError = Fetcher.ErrorWrapper<undefined>;

export type RedirectsControllerFindOneVariables = {
  pathParams: RedirectsControllerFindOnePathParams;
} & ZapdiviserContext['fetcherOptions'];

export const fetchRedirectsControllerFindOne = (variables: RedirectsControllerFindOneVariables, signal?: AbortSignal) =>
  zapdiviserFetch<Record<string, any>, RedirectsControllerFindOneError, undefined, {}, {}, RedirectsControllerFindOnePathParams>({
    url: '/api/redirects/{id}',
    method: 'get',
    ...variables,
    signal
  });

export const useRedirectsControllerFindOne = <TData = Record<string, any>>(
  variables: RedirectsControllerFindOneVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Record<string, any>, RedirectsControllerFindOneError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useZapdiviserContext(options);
  return reactQuery.useQuery<Record<string, any>, RedirectsControllerFindOneError, TData>({
    queryKey: queryKeyFn({ path: '/api/redirects/{id}', operationId: 'redirectsControllerFindOne', variables }),
    queryFn: ({ signal }) => fetchRedirectsControllerFindOne({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type RedirectsControllerUpdatePathParams = {
  id: string;
};

export type RedirectsControllerUpdateError = Fetcher.ErrorWrapper<undefined>;

export type RedirectsControllerUpdateVariables = {
  body?: Schemas.UpdateRedirectDto;
  pathParams: RedirectsControllerUpdatePathParams;
} & ZapdiviserContext['fetcherOptions'];

export const fetchRedirectsControllerUpdate = (variables: RedirectsControllerUpdateVariables, signal?: AbortSignal) =>
  zapdiviserFetch<undefined, RedirectsControllerUpdateError, Schemas.UpdateRedirectDto, {}, {}, RedirectsControllerUpdatePathParams>({
    url: '/api/redirects/{id}',
    method: 'patch',
    ...variables,
    signal
  });

export const useRedirectsControllerUpdate = (
  options?: Omit<reactQuery.UseMutationOptions<undefined, RedirectsControllerUpdateError, RedirectsControllerUpdateVariables>, 'mutationFn'>
) => {
  const { fetcherOptions } = useZapdiviserContext();
  return reactQuery.useMutation<undefined, RedirectsControllerUpdateError, RedirectsControllerUpdateVariables>({
    mutationFn: (variables: RedirectsControllerUpdateVariables) => fetchRedirectsControllerUpdate({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type RedirectsControllerRemovePathParams = {
  id: string;
};

export type RedirectsControllerRemoveError = Fetcher.ErrorWrapper<undefined>;

export type RedirectsControllerRemoveVariables = {
  pathParams: RedirectsControllerRemovePathParams;
} & ZapdiviserContext['fetcherOptions'];

export const fetchRedirectsControllerRemove = (variables: RedirectsControllerRemoveVariables, signal?: AbortSignal) =>
  zapdiviserFetch<undefined, RedirectsControllerRemoveError, undefined, {}, {}, RedirectsControllerRemovePathParams>({
    url: '/api/redirects/{id}',
    method: 'delete',
    ...variables,
    signal
  });

export const useRedirectsControllerRemove = (
  options?: Omit<reactQuery.UseMutationOptions<undefined, RedirectsControllerRemoveError, RedirectsControllerRemoveVariables>, 'mutationFn'>
) => {
  const { fetcherOptions } = useZapdiviserContext();
  return reactQuery.useMutation<undefined, RedirectsControllerRemoveError, RedirectsControllerRemoveVariables>({
    mutationFn: (variables: RedirectsControllerRemoveVariables) => fetchRedirectsControllerRemove({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type RedirectsControllerUpdateLinkPathParams = {
  id: string;
  linkId: string;
};

export type RedirectsControllerUpdateLinkError = Fetcher.ErrorWrapper<undefined>;

export type RedirectsControllerUpdateLinkVariables = {
  body?: Schemas.UpdateRedirectLinkDto;
  pathParams: RedirectsControllerUpdateLinkPathParams;
} & ZapdiviserContext['fetcherOptions'];

export const fetchRedirectsControllerUpdateLink = (variables: RedirectsControllerUpdateLinkVariables, signal?: AbortSignal) =>
  zapdiviserFetch<
    undefined,
    RedirectsControllerUpdateLinkError,
    Schemas.UpdateRedirectLinkDto,
    {},
    {},
    RedirectsControllerUpdateLinkPathParams
  >({ url: '/api/redirects/{id}/link/{linkId}', method: 'patch', ...variables, signal });

export const useRedirectsControllerUpdateLink = (
  options?: Omit<
    reactQuery.UseMutationOptions<undefined, RedirectsControllerUpdateLinkError, RedirectsControllerUpdateLinkVariables>,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useZapdiviserContext();
  return reactQuery.useMutation<undefined, RedirectsControllerUpdateLinkError, RedirectsControllerUpdateLinkVariables>({
    mutationFn: (variables: RedirectsControllerUpdateLinkVariables) =>
      fetchRedirectsControllerUpdateLink({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type RedirectsControllerRemoveLinkPathParams = {
  linkId: string;
};

export type RedirectsControllerRemoveLinkError = Fetcher.ErrorWrapper<undefined>;

export type RedirectsControllerRemoveLinkVariables = {
  pathParams: RedirectsControllerRemoveLinkPathParams;
} & ZapdiviserContext['fetcherOptions'];

export const fetchRedirectsControllerRemoveLink = (variables: RedirectsControllerRemoveLinkVariables, signal?: AbortSignal) =>
  zapdiviserFetch<undefined, RedirectsControllerRemoveLinkError, undefined, {}, {}, RedirectsControllerRemoveLinkPathParams>({
    url: '/api/redirects/link/{linkId}',
    method: 'delete',
    ...variables,
    signal
  });

export const useRedirectsControllerRemoveLink = (
  options?: Omit<
    reactQuery.UseMutationOptions<undefined, RedirectsControllerRemoveLinkError, RedirectsControllerRemoveLinkVariables>,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useZapdiviserContext();
  return reactQuery.useMutation<undefined, RedirectsControllerRemoveLinkError, RedirectsControllerRemoveLinkVariables>({
    mutationFn: (variables: RedirectsControllerRemoveLinkVariables) =>
      fetchRedirectsControllerRemoveLink({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type WhatsappControllerFindAllError = Fetcher.ErrorWrapper<undefined>;

export type WhatsappControllerFindAllResponse = Schemas.WhatsappEntity[];

export type WhatsappControllerFindAllVariables = ZapdiviserContext['fetcherOptions'];

export const fetchWhatsappControllerFindAll = (variables: WhatsappControllerFindAllVariables, signal?: AbortSignal) =>
  zapdiviserFetch<WhatsappControllerFindAllResponse, WhatsappControllerFindAllError, undefined, {}, {}, {}>({
    url: '/api/whatsapp',
    method: 'get',
    ...variables,
    signal
  });

export const useWhatsappControllerFindAll = <TData = WhatsappControllerFindAllResponse>(
  variables: WhatsappControllerFindAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<WhatsappControllerFindAllResponse, WhatsappControllerFindAllError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useZapdiviserContext(options);
  return reactQuery.useQuery<WhatsappControllerFindAllResponse, WhatsappControllerFindAllError, TData>({
    queryKey: queryKeyFn({ path: '/api/whatsapp', operationId: 'whatsappControllerFindAll', variables }),
    queryFn: ({ signal }) => fetchWhatsappControllerFindAll({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type WhatsappControllerCreateError = Fetcher.ErrorWrapper<undefined>;

export type WhatsappControllerCreateVariables = ZapdiviserContext['fetcherOptions'];

export const fetchWhatsappControllerCreate = (variables: WhatsappControllerCreateVariables, signal?: AbortSignal) =>
  zapdiviserFetch<Schemas.WhatsappEntity, WhatsappControllerCreateError, undefined, {}, {}, {}>({
    url: '/api/whatsapp',
    method: 'post',
    ...variables,
    signal
  });

export const useWhatsappControllerCreate = (
  options?: Omit<
    reactQuery.UseMutationOptions<Schemas.WhatsappEntity, WhatsappControllerCreateError, WhatsappControllerCreateVariables>,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useZapdiviserContext();
  return reactQuery.useMutation<Schemas.WhatsappEntity, WhatsappControllerCreateError, WhatsappControllerCreateVariables>({
    mutationFn: (variables: WhatsappControllerCreateVariables) => fetchWhatsappControllerCreate({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type WhatsappControllerUpdateCodeError = Fetcher.ErrorWrapper<undefined>;

export type WhatsappControllerUpdateCodeVariables = ZapdiviserContext['fetcherOptions'];

export const fetchWhatsappControllerUpdateCode = (variables: WhatsappControllerUpdateCodeVariables, signal?: AbortSignal) =>
  zapdiviserFetch<undefined, WhatsappControllerUpdateCodeError, undefined, {}, {}, {}>({
    url: '/api/whatsapp/update-code',
    method: 'post',
    ...variables,
    signal
  });

export const useWhatsappControllerUpdateCode = (
  options?: Omit<
    reactQuery.UseMutationOptions<undefined, WhatsappControllerUpdateCodeError, WhatsappControllerUpdateCodeVariables>,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useZapdiviserContext();
  return reactQuery.useMutation<undefined, WhatsappControllerUpdateCodeError, WhatsappControllerUpdateCodeVariables>({
    mutationFn: (variables: WhatsappControllerUpdateCodeVariables) =>
      fetchWhatsappControllerUpdateCode({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type WhatsappControllerFindOnePathParams = {
  id: string;
};

export type WhatsappControllerFindOneError = Fetcher.ErrorWrapper<undefined>;

export type WhatsappControllerFindOneVariables = {
  pathParams: WhatsappControllerFindOnePathParams;
} & ZapdiviserContext['fetcherOptions'];

export const fetchWhatsappControllerFindOne = (variables: WhatsappControllerFindOneVariables, signal?: AbortSignal) =>
  zapdiviserFetch<Record<string, any>, WhatsappControllerFindOneError, undefined, {}, {}, WhatsappControllerFindOnePathParams>({
    url: '/api/whatsapp/{id}',
    method: 'get',
    ...variables,
    signal
  });

export const useWhatsappControllerFindOne = <TData = Record<string, any>>(
  variables: WhatsappControllerFindOneVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Record<string, any>, WhatsappControllerFindOneError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useZapdiviserContext(options);
  return reactQuery.useQuery<Record<string, any>, WhatsappControllerFindOneError, TData>({
    queryKey: queryKeyFn({ path: '/api/whatsapp/{id}', operationId: 'whatsappControllerFindOne', variables }),
    queryFn: ({ signal }) => fetchWhatsappControllerFindOne({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions
  });
};

export type WhatsappControllerUpdatePathParams = {
  id: string;
};

export type WhatsappControllerUpdateError = Fetcher.ErrorWrapper<undefined>;

export type WhatsappControllerUpdateVariables = {
  pathParams: WhatsappControllerUpdatePathParams;
} & ZapdiviserContext['fetcherOptions'];

export const fetchWhatsappControllerUpdate = (variables: WhatsappControllerUpdateVariables, signal?: AbortSignal) =>
  zapdiviserFetch<undefined, WhatsappControllerUpdateError, undefined, {}, {}, WhatsappControllerUpdatePathParams>({
    url: '/api/whatsapp/{id}',
    method: 'patch',
    ...variables,
    signal
  });

export const useWhatsappControllerUpdate = (
  options?: Omit<reactQuery.UseMutationOptions<undefined, WhatsappControllerUpdateError, WhatsappControllerUpdateVariables>, 'mutationFn'>
) => {
  const { fetcherOptions } = useZapdiviserContext();
  return reactQuery.useMutation<undefined, WhatsappControllerUpdateError, WhatsappControllerUpdateVariables>({
    mutationFn: (variables: WhatsappControllerUpdateVariables) => fetchWhatsappControllerUpdate({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type WhatsappControllerRemovePathParams = {
  id: string;
};

export type WhatsappControllerRemoveError = Fetcher.ErrorWrapper<undefined>;

export type WhatsappControllerRemoveVariables = {
  pathParams: WhatsappControllerRemovePathParams;
} & ZapdiviserContext['fetcherOptions'];

export const fetchWhatsappControllerRemove = (variables: WhatsappControllerRemoveVariables, signal?: AbortSignal) =>
  zapdiviserFetch<Schemas.WhatsappEntity, WhatsappControllerRemoveError, undefined, {}, {}, WhatsappControllerRemovePathParams>({
    url: '/api/whatsapp/{id}',
    method: 'delete',
    ...variables,
    signal
  });

export const useWhatsappControllerRemove = (
  options?: Omit<
    reactQuery.UseMutationOptions<Schemas.WhatsappEntity, WhatsappControllerRemoveError, WhatsappControllerRemoveVariables>,
    'mutationFn'
  >
) => {
  const { fetcherOptions } = useZapdiviserContext();
  return reactQuery.useMutation<Schemas.WhatsappEntity, WhatsappControllerRemoveError, WhatsappControllerRemoveVariables>({
    mutationFn: (variables: WhatsappControllerRemoveVariables) => fetchWhatsappControllerRemove({ ...fetcherOptions, ...variables }),
    ...options
  });
};

export type QueryOperation =
  | {
      path: '/api/user';
      operationId: 'userControllerFindMe';
      variables: UserControllerFindMeVariables;
    }
  | {
      path: '/api/redirects/{slug}';
      operationId: 'redirectsControllerRedirect';
      variables: RedirectsControllerRedirectVariables;
    }
  | {
      path: '/api/redirects';
      operationId: 'redirectsControllerFindAll';
      variables: RedirectsControllerFindAllVariables;
    }
  | {
      path: '/api/redirects/slug-available/{slug}';
      operationId: 'redirectsControllerSlugAvailable';
      variables: RedirectsControllerSlugAvailableVariables;
    }
  | {
      path: '/api/redirects/{id}';
      operationId: 'redirectsControllerFindOne';
      variables: RedirectsControllerFindOneVariables;
    }
  | {
      path: '/api/whatsapp';
      operationId: 'whatsappControllerFindAll';
      variables: WhatsappControllerFindAllVariables;
    }
  | {
      path: '/api/whatsapp/{id}';
      operationId: 'whatsappControllerFindOne';
      variables: WhatsappControllerFindOneVariables;
    };
